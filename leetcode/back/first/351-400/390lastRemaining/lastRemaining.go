package main

import (
	"fmt"
)

func main() {
	fmt.Println(lastRemaining(9))
}

/*
给定一个从1 到 n 排序的整数列表。
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
返回长度为 n 的列表中，最后剩下的数字。
示例：
输入:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6
输出:
6
*/

/*
设n个数时，从左到右开始执行剩下的数为f1(n)，将n个数反转后(即：n,n-1,...,1)，从左到右执行剩下的数为f2(n)
则，f1(n)和f2(n)剩下的数，在他们在各自原数组中的下标一定一样，即两者剩余的数都是下标i位置处的元素。1,...,n和n,...,1两个相同下标的元素相加为n+1
那么f2(n)的元素怎么得到？对于2n个元素，执行一次从左到右之后，剩余的元素除以2，可以得到1,...,n的元素。
如果继续执行，相当于对1,...,n的元素从右到左开始执行(因为第一次已经从左到右执行了)，等价于：对于1,...,n元素从右到左执行的结果*2，即：f1(2n) = 2 * f2(n)
所有得到递推式：f1(n) + f2(n) = n + 1 又由于f2(n) * 2 = f1(2n) 所以：f1(n) + f1(2n) / 2 = n + 1;
用n/2替换n得到：f1(n/2) + f1(n) / 2 = n / 2 + 1 -----> f1(n) = 2 * (n / 2 + 1 - f1(n / 2))
*/
func lastRemaining(n int) int {
	if n == 1 {
		return 1
	}
	return 2 * (n/2 + 1 - lastRemaining(n/2))
}
