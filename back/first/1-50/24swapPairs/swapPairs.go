package main

import (
	"outback/leetcode/back/common/listnode"
)

func main() {
	list1 := listnode.ListNode{Val: 2}
	list1.Next = &listnode.ListNode{Val: 4}
	list1.Next.Next = &listnode.ListNode{Val: 5}
	list1.Next.Next.Next = &listnode.ListNode{Val: 6}
	list1.Next.Next.Next.Next = &listnode.ListNode{Val: 7}
	res := swapPairs(&list1)
	listnode.PrintListNode(res)
}

/*
24. 两两交换链表中的节点
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:
给定 1->2->3->4, 你应该返回 2->1->4->3.
*/

func swapPairs(head *listnode.ListNode) *listnode.ListNode {
	return Iteration(head)
}

// 递归解法
func swap(head *listnode.ListNode) *listnode.ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	firstNode := head
	secondeNode := head.Next
	firstNode.Next = swap(secondeNode.Next)
	secondeNode.Next = firstNode
	return secondeNode
}

// 迭代解法
func Iteration(head *listnode.ListNode) *listnode.ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	dummy := new(listnode.ListNode)
	dummy.Next = head
	prevNode := dummy
	for head != nil && head.Next != nil {

		firstNode := head
		secondNode := head.Next

		// swap
		prevNode.Next = secondNode
		firstNode.Next = secondNode.Next
		secondNode.Next = firstNode

		prevNode = firstNode
		head = firstNode.Next
	}
	return dummy.Next
}

// 这种写法好难理解啊
func SwapLinkedList(head *listnode.ListNode) *listnode.ListNode {
	list := &listnode.ListNode{Next: head}
	for prev, node := list, list.Next; node != nil; node = node.Next {
		if node.Next != nil {
			// prev.Next, treenode.Next, treenode.Next.Next = treenode.Next, treenode.Next.Next, treenode
			swapNode(prev, node, node.Next)
			prev = node
		}
	}
	return list.Next
}

func swapNode(prev, node, next *listnode.ListNode) {
	prev.Next = next
	node.Next = next.Next
	next.Next = node
}

func Iteration2(head *listnode.ListNode) *listnode.ListNode {
	dummy := new(listnode.ListNode)
	dummy.Next = head
	pre := dummy

	for head != nil && head.Next != nil {
		first := head
		nxt := head.Next
		third := head.Next.Next

		pre.Next = nxt
		first.Next = third
		nxt.Next = first

		pre = head
		head = first.Next
	}
	return dummy.Next

	/*
		dummy := new(ListNode)
		dummy.Next = head
		prevNode := dummy
		for head != nil && head.Next != nil {

			firstNode := head
			secondNode := head.Next

			// swap
			prevNode.Next = secondNode
			firstNode.Next = secondNode.Next
			secondNode.Next = firstNode

			prevNode = firstNode
			head = firstNode.Next
		}
		return dummy.Next
	*/
}

// 这种解法是错的，但是没有找到错的原因
func swapPairs3(head *listnode.ListNode) *listnode.ListNode {
	dummy := new(listnode.ListNode)
	dummy.Next = head
	pre := dummy

	for head != nil && head.Next != nil {
		nxt := head.Next
		third := head.Next.Next

		pre.Next = nxt
		nxt.Next = head
		head.Next = nxt.Next

		head = third
		pre = head
	}
	return dummy.Next
}
